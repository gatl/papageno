/* Copyright 2018 noseglasses <shinynoseglasses@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "Generator/PPG_Global.hpp"

#include "ParserTree/PPG_Token.hpp"
#include "ParserTree/PPG_Action.hpp"
#include "ParserTree/PPG_Input.hpp"
#include "ParserTree/PPG_Pattern.hpp"

#include "PPG_Compiler.hpp"

#include <ostream>
#include <fstream>

extern struct gengetopt_args_info ai;

namespace Papageno {
namespace Generator {

  
// Das gleiche fuer all actions
   
void caption(std::ostream &out, const std::string &title)
{
   out <<
"//##############################################################################\n"
"// " << title << "\n"
"//##############################################################################\n"
"\n";
}

static void outputInfoAboutSpecificOverride(std::ostream &out)
{
   out <<
"// The following macro can be defined in a preamble header to customize \n"
"// Papagenos input-action behavior.\n"
"//\n";
}

static void outputInformationOfDefinition(std::ostream &out, const ParserTree::Node &node)
{
   const auto &lod = node.getLOD();
   
//    if(lod) {
//       out <<
// "#line " << lod.location_.first_line << " \"" << lod.file_ << "\"\n";
//    }
//    else {
//       out <<
// "#line\n";
//    }

   out <<
"// " << lod << "\n";
   out <<
"//\n";
}
   
void generateFileHeader(std::ostream &out) {
   
   out <<
"// Generated by Papageno compiler version " << PAPAGENO_VERSION << "\n";
   out <<
"\n";

   caption(out, "File content");
   
   for(std::size_t i = 0; i < Papageno::Parser::filesParsed.size(); ++i) {
      out << 
"/* File " << Papageno::Parser::filesParsed[i] << "\n"
"\n";
      out << Papageno::Parser::codeParsed[i] << "\n"
"*/\n"
"\n";
   }

   out <<
"#include \"detail/ppg_context_detail.h\"\n"
"#include \"detail/ppg_token_detail.h\"\n"
"#include \"detail/ppg_note_detail.h\"\n"
"#include \"detail/ppg_chord_detail.h\"\n"
"#include \"detail/ppg_cluster_detail.h\"\n"
"#include \"ppg_input.h\"\n"
"\n";

   if(ai.preamble_filename_arg) {
      out <<
"#include \"" << ai.preamble_filename_arg << "\"\n";
      out <<
"\n";
   }
   
   out <<
"#ifdef PAPAGENO_PREAMBLE_HEADER\n"
"#include PAPAGENO_PREAMBLE_HEADER\n"
"#endif\n\n";
   
  out <<
"#define PPG_NUM_BITS_LEFT(N_BITS) \\\n"
"   (N_BITS%(8*sizeof(PPG_Bitfield_Storage_Type)))\n\n";
      
   out << 
"#define PPG_NUM_BYTES(N_BITS) \\\n"
"   (N_BITS/(8*sizeof(PPG_Bitfield_Storage_Type)))\n\n";
}

#if 0
void generateGlobalActionInformation(std::ostream &out)
{
   auto actionsByType = ParserTree::Action::getActionsByType();
   
   caption(out, "Actions");

   outputInfoAboutSpecificOverride(out);
   out <<
"#ifndef PPG_CONFIGURE_ACTIONS_GLOBAL\n"
"#define PPG_CONFIGURE_ACTIONS_GLOBAL(...)\n"
"#endif\n\n";

   outputInfoAboutSpecificOverride(out);
   out <<
"#ifndef PPG_CONFIGURE_ACTIONS_LOCAL\n"
"#define PPG_CONFIGURE_ACTIONS_LOCAL(...)\n"
"#endif\n\n";

   for(const auto &abtEntry: actionsByType) {
      const auto &tag = abtEntry.first;
   
      outputInfoAboutSpecificOverride(out);
      out <<
"#ifndef PPG_ACTION_INITIALIZATION___" << tag << "\n";
      out << 
"#define PPG_ACTION_INITIALIZATION___" << tag << "(...) __VA_ARGS__\n";
      out <<
"#endif\n"
"\n";

      out <<
"#define PPG_ACTIONS___" << tag << "(OP) \\\n";

      for(const auto &actionPtr: abtEntry.second) {
         out <<
"   OP(" << actionPtr->getId().getText() << ")\\\n";
      }
      
      out <<
"\n";
         
      outputInfoAboutSpecificOverride(out);
      out <<
   "#ifndef PPG_CONFIGURE_ACTIONS_GLOBAL___" << tag << "\n"
   "#define PPG_CONFIGURE_ACTIONS_GLOBAL___" << tag << "(...) \\\n"
   "   PPG_CONFIGURE_ACTIONS_GLOBAL(__VA_ARGS__)\n"
   "#endif\n\n";

      outputInfoAboutSpecificOverride(out);
      out <<
   "#ifndef PPG_CONFIGURE_ACTIONS_LOCAL___" << tag << "\n"
   "#define PPG_CONFIGURE_ACTIONS_LOCAL___" << tag << "(...) \\\n"
   "   PPG_CONFIGURE_ACTIONS_LOCAL(__VA_ARGS__)\n"
   "#endif\n\n";
   }
   
   out <<
"#define PPG_ACTIONS_ALL(OP) \\\n";

   for(const auto &abtEntry: actionsByType) {
      const auto &tag = abtEntry.first;
      out <<
"   PPG_ACTIONS___" << tag << "(OP) \\\n";
   }
   out << "\n";
   
   out <<
"#define PPG_CUSTOM_CONFIGURE_ACTIONS_GLOBAL \\\n";
   for(const auto &abtEntry: actionsByType) {
      const auto &tag = abtEntry.first;
      out <<
"   PPG_ACTIONS___" << tag << "(PPG_CONFIGURE_ACTIONS_GLOBAL___" << tag << ") \\\n";
   }
   out << 
"\n";

   out <<
"PPG_CUSTOM_CONFIGURE_ACTIONS_GLOBAL\n\n";

   out <<
"#define PPG_CUSTOM_CONFIGURE_ACTIONS_LOCAL \\\n";
   for(const auto &abtEntry: actionsByType) {
      const auto &tag = abtEntry.first;
      out <<
"   PPG_ACTIONS___" << tag << "(PPG_CONFIGURE_ACTIONS_LOCAL___" << tag << ") \\\n";
   }
   out << 
"\n";
}

#endif

template<typename EntitiesByType,
         typename EntityAssignments>
void generateEntityInformation(
            std::ostream &out,
            const EntitiesByType &entitiesByType,
            const EntityAssignments &entityAssignments,
            const std::string &entityType,
            const std::string &entityTypeUpper,
            const std::string &entityTypeAllCaps
     )
{  
   caption(out, entityTypeUpper + "s");
      
   out <<
"// Add a flag to enable local initialization for\n"
"// all input classes.\n"
"//\n"
"#ifdef PPG_ENABLE_" << entityTypeAllCaps << "S_LOCAL_INITIALIZATION_ALL\n";

   for(const auto &entityAssignmentsEntry: entityAssignments) {
      const auto &tag = entityAssignmentsEntry.first;
      
      out <<
"// A flag to toggle specific initialization for tag class \'" << tag << "\'.\n"
"//\n"
"#   ifndef PPG_ENABLE_" << entityTypeAllCaps << "S_LOCAL_INITIALIZATION___" << tag << " \n"
"#      define PPG_ENABLE_" << entityTypeAllCaps << "S_LOCAL_INITIALIZATION___" << tag << " \n"
"#   endif \n";
   }
   out <<
"#endif\n\n";

   out <<
"// Enable the same type of initialization for all tag classes\n"
"//\n"
"#ifndef PPG_" << entityTypeAllCaps << "_INITIALIZE\n"
"#   define PPG_" << entityTypeAllCaps << "_INITIALIZE(ID, ...) __VA_ARGS__\n"
"#endif\n\n";
   
   out <<
"// Distinguish between global and local\n"
"// initialization by tag class.\n"
"//\n"
"// If no class wise initialization is desired\n"
"// we fall back to the common initialization method\n"
"//\n";
   for(const auto &entityAssignmentsEntry: entityAssignments) {
      const auto &tag = entityAssignmentsEntry.first;

      out <<
"// Tag class \'" << tag << "\'.\n" <<
"#ifndef PPG_" << entityTypeAllCaps << "_INITIALIZE___" << tag << "\n"
"#   define PPG_" << entityTypeAllCaps << "_INITIALIZE___" << tag << "(ID, ...) \\\n" <<
"      PPG_" << entityTypeAllCaps << "_INITIALIZE(ID, ##__VA_ARGS__)\n"
"#endif\n"
"\n"
"#ifdef PPG_ENABLE_" << entityTypeAllCaps << "S_LOCAL_INITIALIZATION___" << tag << "\n" <<
"#   ifndef PPG_" << entityTypeAllCaps << "_INITIALIZE_LOCAL___" << tag << "\n" <<
"#      define PPG_" << entityTypeAllCaps << "_INITIALIZE_LOCAL___" << tag << "(ID, PATH, ...) \\\n" <<
"            PATH = PPG_" << entityTypeAllCaps << "_INITIALIZE___" << tag << "(ID, ##__VA_ARGS__);\n" <<
"#   endif\n"
"#   ifndef PPG_" << entityTypeAllCaps << "_INITIALIZE_GLOBAL___" << tag << "\n" <<
"#      define PPG_" << entityTypeAllCaps << "_INITIALIZE_GLOBAL___" << tag << "(ID, ...) 0\n" <<
"#   endif\n"
"#else\n"
"#   ifndef PPG_" << entityTypeAllCaps << "_INITIALIZE_LOCAL___" << tag << "\n" <<
"#      define PPG_" << entityTypeAllCaps << "_INITIALIZE_LOCAL___" << tag << "(ID, PATH, ...)\n"
"#   endif\n"
"#   ifndef PPG_" << entityTypeAllCaps << "_INITIALIZE_GLOBAL___" << tag << "\n" <<
"#      define PPG_" << entityTypeAllCaps << "_INITIALIZE_GLOBAL___" << tag << "(ID, ...) \\\n" <<
"            PPG_" << entityTypeAllCaps << "_INITIALIZE___" << tag << "(ID, ##__VA_ARGS__)\n" <<
"#   endif\n"
"#endif\n"
"\n"         
"// Define a common entry for each tag class to be used for\n"
"// local initialization.\n"
"//\n"
"#define PPG_" << entityTypeAllCaps << "S_INITIALIZE_LOCAL_ALL___" << tag << " \\\n";
      for(const auto &assignment: entityAssignmentsEntry.second) {
         out <<
"   PPG_" << entityTypeAllCaps << "_INITIALIZE_LOCAL___" << tag << "(" << assignment.entity_->getId().getText() << ", " << assignment.pathString_;
         if(assignment.entity_->getParametersDefined()) {
            out << ", " << assignment.entity_->getParameters().getText();
         }
         out << ") \\\n";
      }
      out <<
"\n";
   }
   
   out <<
"// Define a common entry point for local initialization\n"
"//\n"
"#define PPG_" << entityTypeAllCaps << "S_INITIALIZE_LOCAL_ALL \\\n";

   for(const auto &entityAssignmentsEntry: entityAssignments) {
      const auto &tag = entityAssignmentsEntry.first;
      
      out <<
"   PPG_" << entityTypeAllCaps << "S_INITIALIZE_LOCAL_ALL___" << tag << " \\\n";
   }
   out <<
"\n";

   out <<
"// This macro can be used to add configuration of " << entityType << "s at global scope.\n"
"// The default is no configuration at global scope.\n"
"//\n"
"#ifndef PPG_"<< entityTypeAllCaps << "_CONFIGURE_GLOBAL\n"
"#   define PPG_"<< entityTypeAllCaps << "_CONFIGURE_GLOBAL(...)\n"
"#endif\n"
"\n";

   out <<
"// This macro can be used to add configuration of " << entityType << "s at global scope.\n"
"// The default is no configuration at local scope.\n"
"//\n"
"#ifndef PPG_"<< entityTypeAllCaps << "_CONFIGURE_LOCAL\n"
"#   define PPG_"<< entityTypeAllCaps << "_CONFIGURE_LOCAL(...)\n"
"#endif\n"
"\n";

   for(const auto &abtEntry: entitiesByType) {
      const auto &tag = abtEntry.first;
      
      out <<
"// Implement the following macro to enable specific initialization \n"
"// at global scope for tag class \'" << tag << "\'.\n" <<
"//\n"
"#ifndef PPG_" << entityTypeAllCaps << "_CONFIGURE_GLOBAL___" << tag << "\n"
"#   define PPG_" << entityTypeAllCaps << "_CONFIGURE_GLOBAL___" << tag << "(...) \\\n"
"       PPG_" << entityTypeAllCaps << "_CONFIGURE_GLOBAL(__VA_ARGS__)\n"
"#endif\n"
"\n"
"// Implement the following macro to enable specific initialization \n"
"// at local scope for tag class " << tag << ".\n" <<
"//\n"
"#ifndef PPG_" << entityTypeAllCaps << "_CONFIGURE_LOCAL___" << tag << "\n"
"#   define PPG_" << entityTypeAllCaps << "_CONFIGURE_LOCAL___" << tag << "(...) \\\n"
"       PPG_" << entityTypeAllCaps << "_CONFIGURE_LOCAL(__VA_ARGS__)\n"
"#endif\n"
"\n";

      out <<
"// Use this macro to perform specific initializations of " << entityType << "s with\n"
"// tag class \'" << tag << "\'.\n"
"//\n"
"#define PPG_" << entityTypeAllCaps << "S___" << tag << "(OP) \\\n";

      for(const auto &entityPtr: abtEntry.second) {
         out <<
"   OP(" << entityPtr->getId().getText() << ")\\\n";
      }
   }
   out <<
"\n";

   out <<
"#define PPG_" << entityTypeAllCaps << "S_ALL(OP) \\\n";

   for(const auto &abtEntry: entitiesByType) {
      const auto &tag = abtEntry.first;
      out <<
"   PPG_" << entityTypeAllCaps << "S___" << tag << "(OP) \\\n";
   }
   out << "\n"; 

   out <<
"#define PPG_" << entityTypeAllCaps << "S_CONFIGURE_LOCAL_ALL \\\n";
   for(const auto &abtEntry: entitiesByType) {
      const auto &tag = abtEntry.first;
      out <<
"   PPG_" << entityTypeAllCaps << "S___" << tag << "(PPG_" << entityTypeAllCaps << "_CONFIGURE_LOCAL___" << tag << ") \\\n";
   }
   out << 
"\n";  
   
   caption(out, entityTypeUpper + "s global configuration");
   for(const auto &abtEntry: entitiesByType) {
      const auto &tag = abtEntry.first;
      out <<
"// Tag class \'" << tag << "\'\n"
"//\n"
"PPG_" << entityTypeAllCaps << "S___" << tag << "(PPG_" << entityTypeAllCaps << "_CONFIGURE_GLOBAL___" << tag << ")\n";
   }
   out << 
"\n";
}

void recursivelyCollectInputAssignments(ParserTree::InputAssignmentsByTag &iabt, const ParserTree::Token &token)
{
   token.collectInputAssignments(iabt);
    
   for(const auto &childTokenPtr: token.getChildren()) {
      recursivelyCollectInputAssignments(iabt, *childTokenPtr);
   }
}

void generateGlobalInputInformation(std::ostream &out)
{
   auto inputsByType = ParserTree::Input::getInputsByType();
   
   auto root = ParserTree::Pattern::getTreeRoot();
   
   ParserTree::InputAssignmentsByTag iabt;
   recursivelyCollectInputAssignments(iabt, *root);
   
   generateEntityInformation(
      out,
      inputsByType,
      iabt,
      "input",
      "Input",
      "INPUT"
   );
}
   
static void recursivelyCollectActionAssignments(ParserTree::ActionAssignmentsByTag &aabt, const ParserTree::Token &token)
{
   token.collectActionAssignments(aabt);
    
   for(const auto &childTokenPtr: token.getChildren()) {
      recursivelyCollectActionAssignments(aabt, *childTokenPtr);
   }
}

void generateGlobalActionInformation(std::ostream &out)
{
   auto actionsByType = ParserTree::Action::getActionsByType();
   
   auto root = ParserTree::Pattern::getTreeRoot();
   
   ParserTree::ActionAssignmentsByTag aabt;
   recursivelyCollectActionAssignments(aabt, *root);
   
   generateEntityInformation(
      out,
      actionsByType,
      aabt,
      "action",
      "Action",
      "ACTION"
   );
}

void recursivelyOutputToken(std::ostream &out, const ParserTree::Token &token)
{
   for(const auto &childTokenPtr: token.getChildren()) {
      recursivelyOutputToken(out, *childTokenPtr);
   }
   
   outputInformationOfDefinition(out, token);
   token.generateCCode(out);
}

void recursivelyOutputTokenForwardDeclaration(std::ostream &out, const ParserTree::Token &token)
{
   out <<
"extern ";
   token.outputCTokenDeclaration(out);
   out << ";\n";

   for(const auto &childTokenPtr: token.getChildren()) {
      recursivelyOutputTokenForwardDeclaration(out, *childTokenPtr);
   }
}

void recursivelyGetMaxEvents(const ParserTree::Token &token, int curDepth, int &maxDepth, int curInputs, int &maxInputs)
{
   curInputs += token.getNumInputs();
   ++curDepth;
   
   if(token.getChildren().empty()) {
      if(curInputs > maxInputs) {
         maxInputs = curInputs;
      }
      if(curDepth > maxDepth) {
         maxDepth = curDepth;
      }
   }
   else {
      for(const auto &childTokenPtr: token.getChildren()) {
         recursivelyGetMaxEvents(*childTokenPtr, curDepth, maxDepth, curInputs, maxInputs);
      }
   }
}

void generateGlobalContext(std::ostream &out)
{
   auto root = ParserTree::Pattern::getTreeRoot();
   
   caption(out, "Token tree forward declarations");
   
   recursivelyOutputTokenForwardDeclaration(out, *root);
   out << "\n";
   
   caption(out, "Token tree");
   
   // Recursively output token tree
   //
   recursivelyOutputToken(out, *root);
   
   caption(out, "Context");
   
   int maxDepth = 0;
   int maxEvents = 0;
   recursivelyGetMaxEvents(*root, 0, maxDepth, 0, maxEvents);
   assert(maxDepth > 0);
   assert(maxEvents > 0);
   
   out <<
"PPG_Event_Queue_Entry event_buffer[" << maxEvents << "] = { 0 };\n\n";

   out <<
"PPG_Furcation furcations[" << maxDepth << "] = { 0 };\n\n";
   
   out <<
"PPG_Token__ *tokens[" << maxDepth << "] = { 0 };\n\n";
   out <<
"PPG_Context context = {\n"
"   .event_buffer = {\n"
"      .events = event_buffer,\n"
"      .start = 0,\n"
"      .end = 0,\n"
"      .cur = 0,\n"
"      .size = 0,\n"
"      .max_size = " << maxEvents << "\n";
   out <<
"   },\n"
"   .furcation_stack = {\n"
"      .furcations = furcations,\n"
"      .n_furcations = 0,\n"
"      .cur_furcation = 0,\n"
"      .max_furcations = " << maxDepth << "\n";
   out <<
"   },\n"
"   .active_tokens = {\n"
"      .tokens = tokens,\n"
"      .n_tokens = 0,\n"
"      .max_tokens = " << maxDepth << "\n";
   out <<
"   },\n"
"   .pattern_root = &" << root->getId().getText() << ",\n"
"   .tree_depth = " << maxDepth << "\n"
"};\n\n";
}
   
void generateInitializationFunction(std::ostream &out)
{
   caption(out, "Initialization");
   
   out << 
"#define PPG_LOCAL_INITIALIZATION \\\n"
"    /* Configuration of all actions. \\\n"
"     */ \\\n"
"    PPG_ACTIONS_CONFIGURE_LOCAL_ALL \\\n"
"    \\\n"
"    /* Configuration of all inputs. \\\n"
"     */ \\\n"
"    PPG_INPUTS_CONFIGURE_LOCAL_ALL  \\\n"
"    \\\n"
"    /* Local initialization of actions.\n"
"     */ \\\n"
"    PPG_ACTIONS_INITIALIZE_LOCAL_ALL \\\n"
"    \\\n"
"    /* Local initialization of inputs. \\\n"
"     */ \\\n"
"    PPG_INPUTS_INITIALIZE_LOCAL_ALL\n"
"\n"
"void papageno_initialize_context()\n"
"{\n"
"#  ifndef PPG_NO_AUTOMATIC_LOCAL_INITIALIZATION\n"
"   PPG_LOCAL_INITIALIZATION\n"
"#  endif\n"
"\n"
"   ppg_global_initialize_context_static(&context);\n"
"   ppg_context = &context;\n"
"}\n\n";
}

void generateGlobal(const std::string &outputFilename)
{
   std::ofstream outputFile(outputFilename);
   
   generateFileHeader(outputFile);
   
   // Generate global action information
   generateGlobalActionInformation(outputFile);
   
   generateGlobalInputInformation(outputFile);
   
   generateGlobalContext(outputFile);
   
   generateInitializationFunction(outputFile);
   
//    outputFile <<
// "#line\n"
// "\n";
}

} // namespace ParserTree
} // namespace Papageno
